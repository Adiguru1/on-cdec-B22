Docker > container > trust > manually > Docker-swarm > to manage containers automatically

Google > Borg > 2015 > Linux Foundation > Kubernetes(k8s) -> open source, very advance,
high secure, free to use

              KUBERNETES [container orchestration tool]
      cluster
      nodes{ Master node, Worker nodes}
      pods  (smallest unit of deployment in k8s)

  Master node components
 1) API server > Route the request
 2) ETCD  > Store the data here
 3) Scheduler > Schedule the nodes(server)
 4) Controller Manager > keep the resources in your desired state
                          (current state = Desired state)

  Worker node components
 1) Kubelette > create the pod and monitor it
 2) container runtime > provide environment to create container inside pod
 3) Kube-proxy > provide the networking (ip-addresses) to the pod

   
Pod > smallest unit of deployment in k8s
    > wrapper in which we create containers 
    > we can create multiple containers in one pod 
    > pod has its own ip address



Objects -> Cluster
(RESOURCES) > Node
         > Pod 
         > Namespace
         > service - to expose pod outside the cluster 
         > Replica set {Earlier -Replication controller}
         > Deployment
         > StatefulSet
         > Daemonset
         > Ingress 
         > Horizontal Pod Autoscalling
         > config map  and secrets variables 


Cluster - on cloud         , on premises,     on server,        webapplcation
          EKS {managed}       Kubeadm          minikube         killercoda {two node cluster}
          AKS                 Kind            {single node}
          GKE                {Self-Managed}



# kubectl {prefix of k8s commands}
# kubectl run <podname> --image=<imagename>   {to create and run the pod}
# kubectl get <resource-name>
# kubectl get node 
# kubectl get pod -o wide  {described details}


* In a pod there are two container one is main and other is side car container

manifest {yaml file}   "Indentation  maintain"
 
vi pod.yaml

apiVersion: "library"
kind:    "Type of resource"
metadata: "data of data"
spec: "service of pod"




apiVersion:  v1   
kind :  Pod       
metadata:  
  name: demopod
  label:
    team: prod
spec:
  containers:
  - name: container1
    image: nginx
  - name: container2
    image: tomcat 
     

after creation of file please apply it

# kubectl apply -f <filename>



*Port no. of container is imp. for communicate with particular container in a pod
*No two container in same pod can have same port
  
        
-->   Intra-pod communication
1) same pod containers connect
2) Use podIP or localhost to connect

#  kubectl exec -it demo-pod -- bash
#  kubectl exec -it -c container2 demo-pod -- bash

-->  Inter-Pod
 
two different pod communication
  


   

